{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-0b16db7ef37fbd001d833befc9b9abdbed9873aa",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EntryPoint.sol": "project/contracts/EntryPoint.sol",
    "contracts/GhostWallet.sol": "project/contracts/GhostWallet.sol",
    "contracts/GhostWalletFactory.sol": "project/contracts/GhostWalletFactory.sol",
    "contracts/PayMaster.sol": "project/contracts/PayMaster.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/EntryPoint.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract EntryPoint is ReentrancyGuard {\n    \n    struct UserOperation {\n        address sender;\n        uint256 nonce;\n        bytes initCode;\n        bytes callData;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        bytes paymasterAndData;\n        bytes signature;\n    }\n\n    mapping(address => uint256) private nonces;\n\n    event UserOperationExecuted(address wallet, address target, uint256 value, bytes data);\n    event UserOperationSimulated(address sender, bool success, uint256 gasUsed);\n\n    function handleUserOperation(address wallet, address target, uint256 value, bytes calldata data) external nonReentrant {\n        require(msg.sender == wallet, \"Unauthorized\"); \n        require(target != address(this), \"Invalid target\"); \n        require(wallet.code.length > 0, \"Wallet must be a contract\");\n        \n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"Execution failed\");\n        \n        emit UserOperationExecuted(wallet, target, value, data);\n    }\n\n    \n    function getNonce(address sender) external view returns (uint256) {\n        return nonces[sender];\n    }\n\n    function incrementNonce(address sender) internal {\n        nonces[sender]++;\n    }\n\n    function simulateValidation(UserOperation calldata userOp) external returns (bool success, uint256 gasUsed) {\n        uint256 gasBefore = gasleft();\n        \n     \n        require(userOp.nonce == nonces[userOp.sender], \"Invalid nonce\");\n        require(userOp.sender != address(0), \"Invalid sender\");\n        require(userOp.signature.length > 0, \"Invalid signature\");\n        require(userOp.callGasLimit > 0, \"Invalid call gas limit\");\n        require(userOp.verificationGasLimit > 0, \"Invalid verification gas limit\");\n        \n       \n        uint256 gasAfter = gasleft();\n        gasUsed = gasBefore - gasAfter;\n        \n        success = true;\n        \n        emit UserOperationSimulated(userOp.sender, success, gasUsed);\n        \n        return (success, gasUsed);\n    }\n\n    \n    function executeUserOperation(UserOperation calldata userOp) external nonReentrant {\n       \n        require(userOp.nonce == nonces[userOp.sender], \"Invalid nonce\");\n        require(userOp.sender.code.length > 0, \"Sender must be a contract\");\n        \n        // Decode callData to extract target, value, and data\n        (address target, uint256 value, bytes memory data) = abi.decode(\n            userOp.callData,\n            (address, uint256, bytes)\n        );\n        \n        require(target != address(this), \"Invalid target\");\n        \n        // Execute the operation\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"Execution failed\");\n        \n        incrementNonce(userOp.sender);\n        \n        emit UserOperationExecuted(userOp.sender, target, value, data);\n    }\n}"
      },
      "project/contracts/GhostWallet.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\nimport \"@openzeppelin/contracts/utils/Address.sol\";\r\n\r\ncontract GhostWallet is ReentrancyGuard {\r\n    using Address for address;\r\n    \r\n\r\n    address public owner;\r\n    address public immutable entryPoint;\r\n    bool public destroyed;\r\n\r\n    mapping(address => EphemeralKey) private ephemeralKeyData;\r\n\r\n    struct EphemeralKey {\r\n        uint256 expiresAt;\r\n        bool isActive;\r\n    }\r\n\r\n    \r\n    event WalletExecuted(address indexed target, uint256 value);\r\n    event Swept(address indexed to, uint256 amount);\r\n    event Destroyed(address indexed to, uint256 amount);\r\n    event WalletBatchExecuted(uint256 count);\r\n    event EphemeralKeyAdded(address key, uint256 expiresAt);\r\n    event EphemeralKeyRevoked(address key);\r\n\r\n    \r\n\r\n    constructor(address _owner, address _entryPoint) payable {\r\n        require(_owner != address(0), \"Owner cannot be zero\");\r\n        require(_entryPoint != address(0), \"EntryPoint cannot be zero\");\r\n        owner = _owner;\r\n        entryPoint = _entryPoint;\r\n    }\r\n\r\n    receive() external payable {}\r\n\r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n\r\n    modifier notDestroyed() {\r\n        require(!destroyed, \"Wallet is destroyed\");\r\n        _;\r\n    }\r\n\r\n    modifier onlyAuthorized() {\r\n        bool isValidKey = ephemeralKeyData[msg.sender].isActive && \r\n                         block.timestamp < ephemeralKeyData[msg.sender].expiresAt;\r\n        \r\n        require(\r\n            msg.sender == owner || \r\n            msg.sender == entryPoint ||\r\n            isValidKey,\r\n            \"Not authorized\"\r\n        );\r\n        _;\r\n    }\r\n\r\n    \r\n    function execute(address target,uint256 value, bytes memory data) external nonReentrant onlyAuthorized notDestroyed {\r\n        require(target != address(0), \"Target cannot be zero\");\r\n        require(address(this).balance >= value, \"Insufficient balance\");\r\n\r\n        (bool success, bytes memory result) = target.call{value: value}(data);\r\n    if (!success) {\r\n        assembly {\r\n            revert(add(result, 32), mload(result))\r\n        }\r\n\r\n    }\r\n\r\n        emit WalletExecuted(target, value);\r\n    }\r\n\r\n  \r\n    function sweep(address payable _to) external nonReentrant onlyOwner notDestroyed {\r\n        require(_to != address(0), \"Recipient cannot be zero\");\r\n\r\n        uint256 amount = address(this).balance;\r\n        require(amount > 0, \"No funds to sweep\");\r\n\r\n        Address.sendValue(_to, amount);\r\n\r\n        emit Swept(_to, amount);\r\n    }\r\n\r\n   \r\n    function destroy(address payable _to) external nonReentrant onlyOwner notDestroyed {\r\n        require(_to != address(0), \"Recipient cannot be zero\");\r\n        \r\n\r\n        uint256 amount = address(this).balance;\r\n         if (amount > 0) {\r\n            Address.sendValue(_to, amount);\r\n        }\r\n        \r\n        destroyed = true;\r\n        emit Destroyed(_to, amount);\r\n       \r\n    }\r\n\r\n    function executeBatch(address[] calldata targets, uint256[] calldata values,bytes[] calldata datas) external nonReentrant onlyAuthorized notDestroyed {\r\n            require(targets.length == values.length && targets.length == datas.length,\"Array length mismatch\");        \r\n        for (uint256 i = 0; i < targets.length; i++) {\r\n             require(targets[i] != address(0), \"Invalid target\");\r\n            (bool success, bytes memory result) = targets[i].call{value: values[i]}(datas[i]);\r\n\r\n            if (!success) {\r\n                assembly {\r\n                    revert(add(result, 32), mload(result))\r\n                }\r\n            }\r\n        }\r\n\r\n        emit WalletBatchExecuted(targets.length);\r\n\r\n    }\r\n\r\n\r\n    function addEphemeralKey(address _key) external onlyOwner notDestroyed {\r\n        require(_key != address(0), \"Invalid key\");\r\n        require(!ephemeralKeyData[_key].isActive, \"Key already active\");\r\n\r\n        uint256 expiresAt = block.timestamp + 1 hours;\r\n\r\n        ephemeralKeyData[_key] = EphemeralKey({\r\n            expiresAt: expiresAt,\r\n            isActive: true\r\n        });\r\n\r\n        emit EphemeralKeyAdded(_key, expiresAt);\r\n    }\r\n\r\n     function revokeEphemeralKey(address _key) external onlyOwner notDestroyed {\r\n        require(ephemeralKeyData[_key].isActive, \"Key not active\");\r\n        \r\n        ephemeralKeyData[_key].isActive = false;\r\n        emit EphemeralKeyRevoked(_key);\r\n    }\r\n\r\n     function isEphemeralKeyValid(address _key) external view returns (bool) {\r\n        return ephemeralKeyData[_key].isActive && block.timestamp < ephemeralKeyData[_key].expiresAt;\r\n    }\r\n\r\n\r\n}"
      },
      "project/contracts/GhostWalletFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"./GhostWallet.sol\";\r\nimport \"./EntryPoint.sol\";\r\n\r\n\r\ncontract GhostFactory {\r\n\r\n     mapping(address => address[]) private userWallets;\r\n\r\n    event GhostCreated(address wallet, address owner);\r\n\r\n    function createGhost(address owner, address entryPoint) external returns (address) {\r\n        GhostWallet wallet = new GhostWallet(owner, entryPoint);\r\n\r\n        userWallets[owner].push(address(wallet));\r\n\r\n        emit GhostCreated(address(wallet), owner);\r\n        return address(wallet);\r\n    }\r\n\r\n    function getUserWallets(address owner) external view returns (address[] memory) {\r\n        return userWallets[owner];\r\n    }\r\n}\r\n"
      },
      "project/contracts/PayMaster.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\r\n\r\ncontract Paymaster is ReentrancyGuard {\r\n    \r\n    address public owner;\r\n    address public immutable entryPoint;\r\n    \r\n    event GasSponsored(address indexed user, uint256 gasCost);\r\n    event OwnerDeposited(uint256 amount);\r\n    event OwnerWithdrew(uint256 amount);\r\n    \r\n    constructor(address _entryPoint) payable {\r\n        require(_entryPoint != address(0), \"Invalid EntryPoint\");\r\n        owner = msg.sender;\r\n        entryPoint = _entryPoint;\r\n    }\r\n    \r\n    receive() external payable {\r\n        emit OwnerDeposited(msg.value);\r\n    }\r\n    \r\n    modifier onlyOwner() {\r\n        require(msg.sender == owner, \"Not owner\");\r\n        _;\r\n    }\r\n    \r\n    modifier onlyEntryPoint() {\r\n        require(msg.sender == entryPoint, \"Not EntryPoint\");\r\n        _;\r\n    }\r\n    \r\n    \r\n    function deposit() external payable onlyOwner {\r\n        require(msg.value > 0, \"Must deposit something\");\r\n        emit OwnerDeposited(msg.value);\r\n    }\r\n    \r\n   \r\n    function sponsorGas(address user, uint256 gasCost) external payable onlyEntryPoint nonReentrant {\r\n        require(address(this).balance >= gasCost, \"Insufficient paymaster balance\");\r\n        require(msg.value == gasCost, \"Must send exact gas cost\");\r\n        \r\n        emit GasSponsored(user, gasCost);\r\n    }\r\n    \r\n    \r\n    function getBalance() external view returns (uint256) {\r\n        return address(this).balance;\r\n    }\r\n    \r\n    \r\n    function ownerWithdraw(uint256 amount) external onlyOwner nonReentrant {\r\n        require(address(this).balance >= amount, \"Insufficient balance\");\r\n        \r\n        (bool success, ) = owner.call{value: amount}(\"\");\r\n        require(success, \"Withdrawal failed\");\r\n        \r\n        emit OwnerWithdrew(amount);\r\n    }\r\n}"
      }
    }
  }
}