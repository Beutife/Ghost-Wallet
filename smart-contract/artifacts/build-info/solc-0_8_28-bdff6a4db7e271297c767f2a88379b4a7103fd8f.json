{
  "_format": "hh3-sol-build-info-1",
  "id": "solc-0_8_28-bdff6a4db7e271297c767f2a88379b4a7103fd8f",
  "solcVersion": "0.8.28",
  "solcLongVersion": "0.8.28+commit.7893614a",
  "userSourceNameMap": {
    "contracts/EntryPoint.sol": "project/contracts/EntryPoint.sol",
    "contracts/GhostWallet.sol": "project/contracts/GhostWallet.sol",
    "contracts/GhostWalletFactory.sol": "project/contracts/GhostWalletFactory.sol",
    "contracts/PayMaster.sol": "project/contracts/PayMaster.sol",
    "contracts/Zkproofverifier.sol": "project/contracts/Zkproofverifier.sol"
  },
  "input": {
    "language": "Solidity",
    "settings": {
      "evmVersion": "cancun",
      "outputSelection": {
        "*": {
          "": [
            "ast"
          ],
          "*": [
            "abi",
            "evm.bytecode",
            "evm.deployedBytecode",
            "evm.methodIdentifiers",
            "metadata"
          ]
        }
      },
      "remappings": [
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/",
        "project/:@openzeppelin/contracts/=npm/@openzeppelin/contracts@5.4.0/"
      ]
    },
    "sources": {
      "npm/@openzeppelin/contracts@5.4.0/utils/Address.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.4.0) (utils/Address.sol)\n\npragma solidity ^0.8.20;\n\nimport {Errors} from \"./Errors.sol\";\n\n/**\n * @dev Collection of functions related to the address type\n */\nlibrary Address {\n    /**\n     * @dev There's no code at `target` (it is not a contract).\n     */\n    error AddressEmptyCode(address target);\n\n    /**\n     * @dev Replacement for Solidity's `transfer`: sends `amount` wei to\n     * `recipient`, forwarding all available gas and reverting on errors.\n     *\n     * https://eips.ethereum.org/EIPS/eip-1884[EIP1884] increases the gas cost\n     * of certain opcodes, possibly making contracts go over the 2300 gas limit\n     * imposed by `transfer`, making them unable to receive funds via\n     * `transfer`. {sendValue} removes this limitation.\n     *\n     * https://consensys.net/diligence/blog/2019/09/stop-using-soliditys-transfer-now/[Learn more].\n     *\n     * IMPORTANT: because control is transferred to `recipient`, care must be\n     * taken to not create reentrancy vulnerabilities. Consider using\n     * {ReentrancyGuard} or the\n     * https://solidity.readthedocs.io/en/v0.8.20/security-considerations.html#use-the-checks-effects-interactions-pattern[checks-effects-interactions pattern].\n     */\n    function sendValue(address payable recipient, uint256 amount) internal {\n        if (address(this).balance < amount) {\n            revert Errors.InsufficientBalance(address(this).balance, amount);\n        }\n\n        (bool success, bytes memory returndata) = recipient.call{value: amount}(\"\");\n        if (!success) {\n            _revert(returndata);\n        }\n    }\n\n    /**\n     * @dev Performs a Solidity function call using a low level `call`. A\n     * plain `call` is an unsafe replacement for a function call: use this\n     * function instead.\n     *\n     * If `target` reverts with a revert reason or custom error, it is bubbled\n     * up by this function (like regular Solidity function calls). However, if\n     * the call reverted with no returned reason, this function reverts with a\n     * {Errors.FailedCall} error.\n     *\n     * Returns the raw returned data. To convert to the expected return value,\n     * use https://solidity.readthedocs.io/en/latest/units-and-global-variables.html?highlight=abi.decode#abi-encoding-and-decoding-functions[`abi.decode`].\n     *\n     * Requirements:\n     *\n     * - `target` must be a contract.\n     * - calling `target` with `data` must not revert.\n     */\n    function functionCall(address target, bytes memory data) internal returns (bytes memory) {\n        return functionCallWithValue(target, data, 0);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but also transferring `value` wei to `target`.\n     *\n     * Requirements:\n     *\n     * - the calling contract must have an ETH balance of at least `value`.\n     * - the called Solidity function must be `payable`.\n     */\n    function functionCallWithValue(address target, bytes memory data, uint256 value) internal returns (bytes memory) {\n        if (address(this).balance < value) {\n            revert Errors.InsufficientBalance(address(this).balance, value);\n        }\n        (bool success, bytes memory returndata) = target.call{value: value}(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a static call.\n     */\n    function functionStaticCall(address target, bytes memory data) internal view returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.staticcall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Same as {xref-Address-functionCall-address-bytes-}[`functionCall`],\n     * but performing a delegate call.\n     */\n    function functionDelegateCall(address target, bytes memory data) internal returns (bytes memory) {\n        (bool success, bytes memory returndata) = target.delegatecall(data);\n        return verifyCallResultFromTarget(target, success, returndata);\n    }\n\n    /**\n     * @dev Tool to verify that a low level call to smart-contract was successful, and reverts if the target\n     * was not a contract or bubbling up the revert reason (falling back to {Errors.FailedCall}) in case\n     * of an unsuccessful call.\n     */\n    function verifyCallResultFromTarget(\n        address target,\n        bool success,\n        bytes memory returndata\n    ) internal view returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            // only check if target is a contract if the call was successful and the return data is empty\n            // otherwise we already know that it was a contract\n            if (returndata.length == 0 && target.code.length == 0) {\n                revert AddressEmptyCode(target);\n            }\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Tool to verify that a low level call was successful, and reverts if it wasn't, either by bubbling the\n     * revert reason or with a default {Errors.FailedCall} error.\n     */\n    function verifyCallResult(bool success, bytes memory returndata) internal pure returns (bytes memory) {\n        if (!success) {\n            _revert(returndata);\n        } else {\n            return returndata;\n        }\n    }\n\n    /**\n     * @dev Reverts with returndata if present. Otherwise reverts with {Errors.FailedCall}.\n     */\n    function _revert(bytes memory returndata) private pure {\n        // Look for revert reason and bubble it up if present\n        if (returndata.length > 0) {\n            // The easiest way to bubble the revert reason is using memory via assembly\n            assembly (\"memory-safe\") {\n                revert(add(returndata, 0x20), mload(returndata))\n            }\n        } else {\n            revert Errors.FailedCall();\n        }\n    }\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/Errors.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/Errors.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Collection of common custom errors used in multiple contracts\n *\n * IMPORTANT: Backwards compatibility is not guaranteed in future versions of the library.\n * It is recommended to avoid relying on the error API for critical functionality.\n *\n * _Available since v5.1._\n */\nlibrary Errors {\n    /**\n     * @dev The ETH balance of the account is not enough to perform the operation.\n     */\n    error InsufficientBalance(uint256 balance, uint256 needed);\n\n    /**\n     * @dev A call to an address target failed. The target may have reverted.\n     */\n    error FailedCall();\n\n    /**\n     * @dev The deployment failed.\n     */\n    error FailedDeployment();\n\n    /**\n     * @dev A necessary precompile is missing.\n     */\n    error MissingPrecompile(address);\n}\n"
      },
      "npm/@openzeppelin/contracts@5.4.0/utils/ReentrancyGuard.sol": {
        "content": "// SPDX-License-Identifier: MIT\n// OpenZeppelin Contracts (last updated v5.1.0) (utils/ReentrancyGuard.sol)\n\npragma solidity ^0.8.20;\n\n/**\n * @dev Contract module that helps prevent reentrant calls to a function.\n *\n * Inheriting from `ReentrancyGuard` will make the {nonReentrant} modifier\n * available, which can be applied to functions to make sure there are no nested\n * (reentrant) calls to them.\n *\n * Note that because there is a single `nonReentrant` guard, functions marked as\n * `nonReentrant` may not call one another. This can be worked around by making\n * those functions `private`, and then adding `external` `nonReentrant` entry\n * points to them.\n *\n * TIP: If EIP-1153 (transient storage) is available on the chain you're deploying at,\n * consider using {ReentrancyGuardTransient} instead.\n *\n * TIP: If you would like to learn more about reentrancy and alternative ways\n * to protect against it, check out our blog post\n * https://blog.openzeppelin.com/reentrancy-after-istanbul/[Reentrancy After Istanbul].\n */\nabstract contract ReentrancyGuard {\n    // Booleans are more expensive than uint256 or any type that takes up a full\n    // word because each write operation emits an extra SLOAD to first read the\n    // slot's contents, replace the bits taken up by the boolean, and then write\n    // back. This is the compiler's defense against contract upgrades and\n    // pointer aliasing, and it cannot be disabled.\n\n    // The values being non-zero value makes deployment a bit more expensive,\n    // but in exchange the refund on every call to nonReentrant will be lower in\n    // amount. Since refunds are capped to a percentage of the total\n    // transaction's gas, it is best to keep them low in cases like this one, to\n    // increase the likelihood of the full refund coming into effect.\n    uint256 private constant NOT_ENTERED = 1;\n    uint256 private constant ENTERED = 2;\n\n    uint256 private _status;\n\n    /**\n     * @dev Unauthorized reentrant call.\n     */\n    error ReentrancyGuardReentrantCall();\n\n    constructor() {\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Prevents a contract from calling itself, directly or indirectly.\n     * Calling a `nonReentrant` function from another `nonReentrant`\n     * function is not supported. It is possible to prevent this from happening\n     * by making the `nonReentrant` function external, and making it call a\n     * `private` function that does the actual work.\n     */\n    modifier nonReentrant() {\n        _nonReentrantBefore();\n        _;\n        _nonReentrantAfter();\n    }\n\n    function _nonReentrantBefore() private {\n        // On the first call to nonReentrant, _status will be NOT_ENTERED\n        if (_status == ENTERED) {\n            revert ReentrancyGuardReentrantCall();\n        }\n\n        // Any calls to nonReentrant after this point will fail\n        _status = ENTERED;\n    }\n\n    function _nonReentrantAfter() private {\n        // By storing the original value once again, a refund is triggered (see\n        // https://eips.ethereum.org/EIPS/eip-2200)\n        _status = NOT_ENTERED;\n    }\n\n    /**\n     * @dev Returns true if the reentrancy guard is currently set to \"entered\", which indicates there is a\n     * `nonReentrant` function in the call stack.\n     */\n    function _reentrancyGuardEntered() internal view returns (bool) {\n        return _status == ENTERED;\n    }\n}\n"
      },
      "project/contracts/EntryPoint.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ninterface IPaymaster {\n    function sponsorGas(address user, uint256 gasCost) external payable;\n}\n\ncontract EntryPoint is ReentrancyGuard {\n    address public paymaster;\n\n    struct UserOperation {\n        address sender;\n        uint256 nonce;\n        bytes initCode;\n        bytes callData;\n        uint256 callGasLimit;\n        uint256 verificationGasLimit;\n        uint256 preVerificationGas;\n        uint256 maxFeePerGas;\n        uint256 maxPriorityFeePerGas;\n        bytes paymasterAndData;\n        bytes signature;\n    }\n\n    mapping(address => uint256) private nonces;\n\n    event UserOperationExecuted(address wallet, address target, uint256 value, bytes data);\n    event UserOperationSimulated(address sender, bool success, uint256 gasUsed);\n    event PaymasterSet(address paymaster);\n    event GasSponsored(address indexed user, uint256 gasCost);\n\n    constructor(address _paymaster) {\n         paymaster = _paymaster;\n            if (_paymaster != address(0)) {\n                 emit PaymasterSet(_paymaster);\n            }\n    }\n\n    function setPaymaster(address _paymaster) external {\n        require(_paymaster != address(0), \"Invalid paymaster\");\n        paymaster = _paymaster;\n        emit PaymasterSet(_paymaster);\n    }\n\n    function getNonce(address sender) external view returns (uint256) {\n        return nonces[sender];\n    }\n\n    function incrementNonce(address sender) internal {\n        nonces[sender]++;\n    }\n\n    function handleUserOperation(address wallet, address target, uint256 value, bytes calldata data)\n        external\n        nonReentrant\n    {\n        require(msg.sender == wallet, \"Unauthorized\");\n        require(target != address(this), \"Invalid target\");\n        require(wallet.code.length > 0, \"Wallet must be a contract\");\n\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"Execution failed\");\n\n        emit UserOperationExecuted(wallet, target, value, data);\n    }\n\n    function simulateValidation(UserOperation calldata userOp)\n        external\n        returns (bool success, uint256 gasUsed)\n    {\n        uint256 gasBefore = gasleft();\n\n        require(userOp.nonce == nonces[userOp.sender], \"Invalid nonce\");\n        require(userOp.sender != address(0), \"Invalid sender\");\n        require(userOp.signature.length > 0, \"Invalid signature\");\n\n        uint256 gasAfter = gasleft();\n        gasUsed = gasBefore - gasAfter;\n        success = true;\n\n        emit UserOperationSimulated(userOp.sender, success, gasUsed);\n        return (success, gasUsed);\n    }\n\n    function executeUserOperation(UserOperation calldata userOp)\n        external\n        nonReentrant\n        payable\n    {\n        require(userOp.nonce == nonces[userOp.sender], \"Invalid nonce\");\n        require(userOp.sender.code.length > 0, \"Sender must be a contract\");\n\n        (address target, uint256 value, bytes memory data) = abi.decode(\n            userOp.callData,\n            (address, uint256, bytes)\n        );\n\n        require(target != address(this), \"Invalid target\");\n\n        uint256 gasBefore = gasleft();\n\n        (bool success, ) = target.call{value: value}(data);\n        require(success, \"Execution failed\");\n\n        uint256 gasUsed = gasBefore - gasleft();\n        uint256 gasCost = gasUsed * tx.gasprice;\n\n        // Paymaster covers the gas\n        IPaymaster(paymaster).sponsorGas{value: gasCost}(userOp.sender, gasCost);\n        emit GasSponsored(userOp.sender, gasCost);\n\n        incrementNonce(userOp.sender);\n\n        emit UserOperationExecuted(userOp.sender, target, value, data);\n    }\n}\n"
      },
      "project/contracts/GhostWallet.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\nimport \"@openzeppelin/contracts/utils/Address.sol\";\n\ncontract GhostWallet is ReentrancyGuard {\n    using Address for address;\n    \n\n    address public owner;\n    address public immutable entryPoint;\n    bool public destroyed;\n\n    mapping(address => EphemeralKey) private ephemeralKeyData;\n\n    struct EphemeralKey {\n        uint256 expiresAt;\n        bool isActive;\n    }\n\n    \n    event WalletExecuted(address indexed target, uint256 value);\n    event Swept(address indexed to, uint256 amount);\n    event Destroyed(address indexed to, uint256 amount);\n    event WalletBatchExecuted(uint256 count);\n    event EphemeralKeyAdded(address key, uint256 expiresAt);\n    event EphemeralKeyRevoked(address key);\n    event Deposited(address indexed from, uint256 amount);\n\n    \n\n    constructor(address _owner, address _entryPoint) payable {\n        require(_owner != address(0), \"Owner cannot be zero\");\n        require(_entryPoint != address(0), \"EntryPoint cannot be zero\");\n        owner = _owner;\n        entryPoint = _entryPoint;\n    }\n\n    receive() external payable {}\n\n\n    function deposit() external payable notDestroyed {\n        require(msg.value > 0, \"Must send ETH\");\n        emit Deposited(msg.sender, msg.value);\n    }\n\n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n\n    modifier notDestroyed() {\n        require(!destroyed, \"Wallet is destroyed\");\n        _;\n    }\n\n    modifier onlyAuthorized() {\n        bool isValidKey = ephemeralKeyData[msg.sender].isActive && \n                         block.timestamp < ephemeralKeyData[msg.sender].expiresAt;\n        \n        require(\n            msg.sender == owner || \n            msg.sender == entryPoint ||\n            isValidKey,\n            \"Not authorized\"\n        );\n        _;\n    }\n\n    \n    function execute(address target,uint256 value, bytes memory data) external nonReentrant onlyAuthorized notDestroyed {\n        require(target != address(0), \"Target cannot be zero\");\n        require(address(this).balance >= value, \"Insufficient balance\");\n\n        (bool success, bytes memory result) = target.call{value: value}(data);\n    if (!success) {\n        assembly {\n            revert(add(result, 32), mload(result))\n        }\n\n    }\n\n        emit WalletExecuted(target, value);\n    }\n\n  \n    function sweep(address payable _to) external nonReentrant onlyOwner notDestroyed {\n        require(_to != address(0), \"Recipient cannot be zero\");\n\n        uint256 amount = address(this).balance;\n        require(amount > 0, \"No funds to sweep\");\n\n        Address.sendValue(_to, amount);\n\n        emit Swept(_to, amount);\n    }\n\n   \n    function destroy(address payable _to) external nonReentrant onlyOwner notDestroyed {\n        require(_to != address(0), \"Recipient cannot be zero\");\n        \n\n        uint256 amount = address(this).balance;\n         if (amount > 0) {\n            Address.sendValue(_to, amount);\n        }\n        \n        destroyed = true;\n        emit Destroyed(_to, amount);\n       \n    }\n\n    function executeBatch(address[] calldata targets, uint256[] calldata values,bytes[] calldata datas) external nonReentrant onlyAuthorized notDestroyed {\n            require(targets.length == values.length && targets.length == datas.length,\"Array length mismatch\");        \n        for (uint256 i = 0; i < targets.length; i++) {\n             require(targets[i] != address(0), \"Invalid target\");\n            (bool success, bytes memory result) = targets[i].call{value: values[i]}(datas[i]);\n\n            if (!success) {\n                assembly {\n                    revert(add(result, 32), mload(result))\n                }\n            }\n        }\n\n        emit WalletBatchExecuted(targets.length);\n\n    }\n\n\n    function addEphemeralKey(address _key) external onlyOwner notDestroyed {\n        require(_key != address(0), \"Invalid key\");\n        require(!ephemeralKeyData[_key].isActive, \"Key already active\");\n\n        uint256 expiresAt = block.timestamp + 1 hours;\n\n        ephemeralKeyData[_key] = EphemeralKey({\n            expiresAt: expiresAt,\n            isActive: true\n        });\n\n        emit EphemeralKeyAdded(_key, expiresAt);\n    }\n\n     function revokeEphemeralKey(address _key) external onlyOwner notDestroyed {\n        require(ephemeralKeyData[_key].isActive, \"Key not active\");\n        \n        ephemeralKeyData[_key].isActive = false;\n        emit EphemeralKeyRevoked(_key);\n    }\n\n     function isEphemeralKeyValid(address _key) external view returns (bool) {\n        return ephemeralKeyData[_key].isActive && block.timestamp < ephemeralKeyData[_key].expiresAt;\n    }\n\n\n}"
      },
      "project/contracts/GhostWalletFactory.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"./GhostWallet.sol\";\nimport \"./EntryPoint.sol\";\n\n\ncontract GhostFactory {\n\n     address public immutable entryPoint;\n     mapping(address => address[]) private userWallets;\n\n    event GhostCreated(address wallet, address owner);\n\n     constructor(address _entryPoint) {\n        require(_entryPoint != address(0), \"Invalid EntryPoint\");\n        entryPoint = _entryPoint;\n    }\n\n    function createGhost(address owner) external payable returns (address) {\n        GhostWallet wallet = new GhostWallet{value: msg.value}(owner, entryPoint);\n        userWallets[owner].push(address(wallet));\n\n        emit GhostCreated(address(wallet), owner);\n        return address(wallet);\n    }\n\n    function getUserWallets(address owner) external view returns (address[] memory) {\n        return userWallets[owner];\n    }\n}\n"
      },
      "project/contracts/PayMaster.sol": {
        "content": "// SPDX-License-Identifier: MIT\npragma solidity ^0.8.20;\n\nimport \"@openzeppelin/contracts/utils/ReentrancyGuard.sol\";\n\ncontract Paymaster is ReentrancyGuard {\n    \n    address public owner;\n    address public immutable entryPoint;\n    \n    event GasSponsored(address indexed user, uint256 gasCost);\n    event OwnerDeposited(uint256 amount);\n    event OwnerWithdrew(uint256 amount);\n    \n    constructor(address _entryPoint) payable {\n        require(_entryPoint != address(0), \"Invalid EntryPoint\");\n        owner = msg.sender;\n        entryPoint = _entryPoint;\n    }\n    \n    receive() external payable {\n        emit OwnerDeposited(msg.value);\n    }\n    \n    modifier onlyOwner() {\n        require(msg.sender == owner, \"Not owner\");\n        _;\n    }\n    \n    modifier onlyEntryPoint() {\n        require(msg.sender == entryPoint, \"Not EntryPoint\");\n        _;\n    }\n    \n    \n    function deposit() external payable onlyOwner {\n        require(msg.value > 0, \"Must deposit something\");\n        emit OwnerDeposited(msg.value);\n    }\n    \n   \n    function sponsorGas(address user, uint256 gasCost) external payable onlyEntryPoint nonReentrant {\n        require(address(this).balance >= gasCost, \"Insufficient paymaster balance\");\n        require(msg.value == gasCost, \"Must send exact gas cost\");\n        \n        emit GasSponsored(user, gasCost);\n    }\n    \n    \n    function getBalance() external view returns (uint256) {\n        return address(this).balance;\n    }\n    \n    \n    function ownerWithdraw(uint256 amount) external onlyOwner nonReentrant {\n        require(address(this).balance >= amount, \"Insufficient balance\");\n        \n        (bool success, ) = owner.call{value: amount}(\"\");\n        require(success, \"Withdrawal failed\");\n        \n        emit OwnerWithdrew(amount);\n    }\n}"
      },
      "project/contracts/Zkproofverifier.sol": {
        "content": "// SPDX-License-Identifier: MIT\r\npragma solidity ^0.8.20;\r\n\r\ncontract ZKProofVerifier {\r\n    \r\n    \r\n    mapping(bytes32 => bool) public usedProofs;\r\n    \r\n    event ProofVerified(bytes32 indexed proofHash, bool isValid);\r\n    \r\n   \r\n    function verifyProof(\r\n        bytes calldata proof,\r\n        uint256[] calldata publicSignals\r\n    ) public pure returns (bool isValid) {\r\n        require(proof.length > 0, \"Empty proof\");\r\n        require(publicSignals.length > 0, \"Empty signals\");\r\n        \r\n        // TODO: Replace with actual Groth16 verifier\r\n        // For hackathon demo: return true if inputs are valid\r\n        return true;\r\n    }\r\n    \r\n    \r\n    function verifyAndRecord(\r\n        bytes calldata proof,\r\n        uint256[] calldata publicSignals\r\n    ) external returns (bool isValid) {\r\n        \r\n        bytes32 proofHash = keccak256(abi.encodePacked(proof, publicSignals));\r\n        \r\n       \r\n        require(!usedProofs[proofHash], \"Proof already used\");\r\n        \r\n    \r\n        isValid = verifyProof(proof, publicSignals);\r\n        require(isValid, \"Invalid proof\");\r\n        \r\n      \r\n        usedProofs[proofHash] = true;\r\n        \r\n        emit ProofVerified(proofHash, isValid);\r\n        \r\n        return isValid;\r\n    }\r\n    \r\n   \r\n    function isProofUsed(bytes32 proofHash) external view returns (bool) {\r\n        return usedProofs[proofHash];\r\n    }\r\n}"
      }
    }
  }
}